# [JPA 소개]

JPA 소개
============================
"왜 실무에서 객체 지향의 장점을 포기하며 제대로 된 객체 모델링은 하지 않으며, 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하도록 개발하고 있는가"
객체 모델링을 세밀하게 할 수 록 객체 모델링을 SQL로 풀어내기 위한 많은 코드와 노력이 필요했다. 
그래서 객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해주는 ORM(Object Relational Mapping) 프레임워크가 등장했다. 
JPA는 자바 진영에서 힘을 모아 만든 ORM 기술 표준

JPA는 실행시점에 자동으로 SQL을 만들어서 실행하는데, 개발자는 SQL을 직접 작성하는 것이 아니기 때문에 어떤 SQL이 실행될지 생각 및 예측해보면 된다.

JPA 성능 문제에 대한 대안
=============================
  - 네이티브 SQL 기능: 직접 SQL 작성 가능
  - 데이터베이스 쿼리 힌트 사용

JPA 도입 장점
===============================
  - 생산성
  - 유지보수
  - 편리한 테스트 작성
  - 버그 감소
  - 개발 단계에서 손쉬운 데이터베이스 변경

SQL을 직접 다룰 때 발생하는 문제점
=================================
1. 반복, 반복, 반복  
: JDBC API 사용 시,   
SQL작성, ResultSet으로 실행 및 객체로 매핑, PreparedStatement로 SQL에 객체의 값 전달 등   
같은 코드가 반복되는 현상을 찾아볼 수 있다.  
2. SQL에 의존적인 개발  
객체에 속성하나를 추가하기 위해서, 객체에 속성 추가, 작성된 INSERT, SELECT, UPDATE SQL 에 해당 속성 추가하기 위한 코드 변경 작업이 필요해진다.  
객체의 속성에 다른 객체와 연관되는 속성을 추가한 경우, DAO에서 작성된 SQL 을 확인하고, 알맞은 SQL 을 실행하는 메서드를 작성하거나 호출하도록 변경해야한다.  

__이러한 이유로 객체와 SQL의 강한 연결로 진정한 의미의 계층 분할이 어려우며, 엔티티를 신뢰할 수 없게 된다.__
  
  ```  
  JPA와 문제해결  
    개발자가 SQL을 직접 작성하는 것이 아니고, JPA의 메서드를 사용한다.   
    예를 들어, 
    저장을 위한 persist(entity), 조회를 위한 find(class, id)  
    수정을 위한 find(class, id) 와 setter 활용 
    (객체를 조회해서 값을 변경하면 트랜잭션 커밋 시, 데이터베이스에 적절한 update sql이 전달된다.),  
    연관된 객체 조회를 위한 find(class, id) 와 getter 활용  
    처럼 메소드를 활용하여 코드로 작성하면 SQL이 생성되고 데이터베이스로 전달된다.
  ```
    
패러다임의 불일치
=============================
: 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르기 때문에 객체 구조를 테이블 구조에 저장하는 데에 한계를 의미.
1. 상속  
  자바의 상속에 대한 기능이 테이블에는 없다.   
  데이터베이스 모델링에서 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 가장 유사한 형태로 테이블을 설계할 수 있다.  
  하지만, 부모 객체에서 부모 데이터만 꺼내고,  
  자식 객체에서 자식 데이터만 꺼내어 원하는 SQL문 작성을 해야하고, 데이터 타입까지 신경써야한다.  
  __JPA는 마치 자바 컬렉션에 객체를 저장하듯 JPA에게 객체를 저장하면 된다.__   
  PARENT 객체를 상속받은 CHILD 객체가 존재한다고 가정할 때,
  
  ```
  // 저장
  jpa.persist(child); 
  // INSERT INTO PARENT... , INSERT INTO CHILD... SQL 문 생성됨

  //조회
  String childId = "id001";
  Child child = jpa.find(Child.class, childId); 
  // SELECT P.*, C.* FROM PARENT P JOIN CHILD C ON P.childId = C.childId SQL문 생성 됨
  ```
    
2. 연관관계    
  객체 모델은 외래 키가 필요 없고 참조가 있으면 되는 반면 테이블은 참조가 필요 없고 외래 키만 있으면 된다.     
  아주 간단한 예시를 들자면, child.getParent().getId() 같이 개발자가 중간에서 변환 역할을 해야 한다.    
  __JPA는 SETTER 로 연관관계를 설정해주고, PERSIST() 메서드로 저장이 가능하다.    
  FIND() 메서드를 통한 조회 후 외래 키를 참조로 변환하는 일도 해준다.__  

```
// 저장
child.setParent(parent);
jpa.persist(child);

//조회
Child child = jpa.find(Child.class, childId);
Parent parent = child.getChild();
```
  
3. 객체 그래프 탐색    
  (객체의 연관관계를 이은 것을 객체 그래프라고 칭함)  
  객체의 연관관계가 설계되었다면, 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다.  
  그렇지만, 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는 지 정해지기 때문에,  
  결국 데이터 접근 계층을 살펴보고 나서야 코드를 작성할 수 있다.    
  __JPA는 지연 로딩을 이용하여 신뢰하고 객체 그래프를 마음껏 탐색할 수 있도록 해준다.    
  지연 로딩이란 실체 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다는 의미의 용어다.__  
  *지연로딩에 대해서는 나중에 더 찾아봐야겠다.*    
    
    
  4. 비교    
    데이터베이스는 기본 키 값으로 각 로우를 구분  
    객체는 동일성 과 동등성이라는 2가지 방법으로 구분  
    *동일성 : ==. 객체 인스턴스의 주소 값 비교*  
    *동등성: equals() 메서드. 객체 내부 값 비교*  
    테이블과 객체의 비교에 차이점이 있다.  
    어떤 상황이 발생하냐면...  
    
```
"SELECT * FROM CUSTOMER WHERE CUSTOMER_ID = ?" 
을 JDBC로 실행하고 CUSTOMER 객체를 반환하는 getCustomer() 메서드가 있다고 할 때,

String customerId = "001";
Customer customer1 = customerDAO.getCustomer(customerId);
Customer customer2 = customerDAO.getCustomer(customerId);

custoemr1 == customer2 //false
```
    
  테이블의 같은 로우에서 조회했지만,   
  객체 측면에서 볼 때 둘은 다른 인스턴스이기 때문에 마지막 코드는 false를 출력한다.  
  만약, 객체를 컬렉션에 보관했다면 아래 처럼 동일성 비교에 성공했을 것이다.  

```
Customer customer1 = list.get(0);
Customer customer2 = list.get(1);

customer1 == cusomer2 // true
```

  이러한 비교의 불일치 때문에 데이터베이스의 같은 로우를 조회할 때마다   
  같은 인스턴스를 반환하도록 구현하는 것은 쉽지 않다.    
  트랜잭션이 동시에 실행되는 상황까지 고려하면 문제가 더 어려워 진다.    
  __JPA 는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.__ 
  아래와 같은 의미이다.

    ```
    String customerId = "001";
    Customer customer1 = jpa.find(Customer.class, customerId);
    Customer customer2 = jpa.find(Customer.class, customerId);
    
    customer1 == cusomer2 // true
    ```
    
# 정리  
정교한 객체 모델링을 할수록 객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이     
서로 다르기 때문에 그 사이에서 개발자는 차이를 극복하기 위해   
소비되는 비용이 점점 증가할 것이다.  
  
이는 객체 모델링이 아닌 데이터 중심의 모델로 변하도록 한다.  
자바에서 이러한 패러다임의 차이를 극복하기 위해 나온 것이 
JPA 이며 *정교한 객체 모델링*을 유지하게 도와준다.




[참고 자료]  
스프링 데이터 예제 프로젝트로 배우는 전자정부 표준 데이터베이스 프레임워크 자바 ORM 표준 JPA 프로그래밍  
[김영한 지음. 에이콘출판주식회사]  

